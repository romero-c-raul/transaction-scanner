import { POST } from "@/app/api/parse-receipt/route";
import { resetRateLimiter } from "@/lib/rate-limit";
import { NextRequest } from "next/server";

// --- Mock Setup ---
// Tell Jest: when any code imports "openai", use this fake instead.
// This prevents real API calls (which cost money and are slow).
jest.mock("openai", () => {
  // Create the mock function outside the constructor so tests can
  // configure its return value (e.g., mockParse.mockResolvedValue(...))
  const mockParse = jest.fn();

  return {
    __esModule: true,
    // When the route does `new OpenAI()`, it gets this fake object.
    // The only method we need to fake is `beta.chat.completions.parse`
    // because that's the structured output method used in lib/openai.ts.
    default: jest.fn().mockImplementation(() => ({
      beta: {
        chat: {
          completions: {
            parse: mockParse,
          },
        },
      },
    })),
  };
});

// --- Helper Function ---
// Creates a fake NextRequest with a JSON body, similar to how
// you'd create a mock `req` object in Express tests.
function createRequest(body: object): NextRequest {
  return new NextRequest("http://localhost:3000/api/parse-receipt", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
}

describe("POST /api/parse-receipt", () => {
  // Reference to the mock so each test can configure what it returns
  let mockParse: jest.Mock;

  beforeEach(() => {
    // Reset rate limiter so each test starts with a clean slate
    resetRateLimiter();

    // Clear all mock call history between tests
    jest.clearAllMocks();

    // Get a reference to the mockParse function by constructing
    // a new instance of the mocked OpenAI class
    const OpenAI = require("openai").default;
    const openaiInstance = new OpenAI();
    mockParse = openaiInstance.beta.chat.completions.parse;

    // Most tests need an API key to be set. The few tests that
    // don't (like the "missing key" test) will delete it.
    process.env.OPENAI_API_KEY = "sk-test-key";
  });

  it("returns parsed receipt data for valid OCR text", async () => {
    // Arrange: configure the mock to return a valid parsed receipt.
    // This is what OpenAI's structured output API would return.
    mockParse.mockResolvedValue({
      choices: [
        {
          message: {
            parsed: {
              store: "Walmart",
              date: "2024-01-15",
              items: [
                { name: "Milk 2%", price: 3.99 },
                { name: "Bread", price: 2.49 },
              ],
              tax: 0.52,
              total: 7.0,
            },
          },
        },
      ],
    });

    // Act: send a request with OCR text
    const request = createRequest({
      text: "WALMART\nMilk 2% $3.99\nBread $2.49\nTax $0.52\nTotal $7.00",
    });
    const response = await POST(request);
    const data = await response.json();

    // Assert: 200 status and correct shape
    expect(response.status).toBe(200);
    expect(data.store).toBe("Walmart");
    expect(data.date).toBe("2024-01-15");
    expect(data.items).toHaveLength(2);
    expect(data.tax).toBe(0.52);
    expect(data.total).toBe(7.0);

    // Assert: each item has an id (generated by our code, not OpenAI)
    expect(data.items[0].id).toBeDefined();
    expect(typeof data.items[0].id).toBe("string");
    expect(data.items[0].name).toBe("Milk 2%");
    expect(data.items[0].price).toBe(3.99);
  });

  // --- Sub-step 4b: Input validation tests ---
  // These test that the route rejects bad input BEFORE calling OpenAI.
  // No mock configuration needed — the route should return 400
  // without ever reaching the OpenAI call.

  it("returns 400 when text is missing", async () => {
    // Act: send a request with no text field
    const request = createRequest({});
    const response = await POST(request);
    const data = await response.json();

    // Assert: 400 with an error message
    expect(response.status).toBe(400);
    expect(data.error).toBeDefined();
  });

  it("returns 400 when text exceeds maximum length", async () => {
    // Arrange: create a string longer than the 10,000 character limit.
    // The route should reject this to prevent expensive OpenAI calls.
    const longText = "a".repeat(10_001);

    // Act
    const request = createRequest({ text: longText });
    const response = await POST(request);
    const data = await response.json();

    // Assert: 400 with an error mentioning "length"
    expect(response.status).toBe(400);
    expect(data.error).toMatch(/length/i);
  });

  // --- Sub-step 4c: Error handling tests ---
  // These test that the route handles server-side failures gracefully
  // and never leaks internal details (like API keys or stack traces)
  // to the client.

  it("returns 500 when OPENAI_API_KEY is not configured", async () => {
    // Arrange: remove the API key that beforeEach sets.
    // This simulates a deployment where someone forgot to configure it.
    delete process.env.OPENAI_API_KEY;

    // Act
    const request = createRequest({ text: "some receipt text" });
    const response = await POST(request);
    const data = await response.json();

    // Assert: 500 with a generic message (no key details leaked)
    expect(response.status).toBe(500);
    expect(data.error).toBeDefined();
    expect(data.error).not.toMatch(/sk-/); // must not leak the key format
  });

  it("returns 500 with sanitized message when OpenAI call fails", async () => {
    // Arrange: mock throws an error that contains sensitive info.
    // In production, OpenAI errors might include your API key or
    // internal details — the route must strip all of that out.
    mockParse.mockRejectedValue(
      new Error("Request failed: invalid API key sk-abc123")
    );

    // Act
    const request = createRequest({ text: "some receipt text" });
    const response = await POST(request);
    const data = await response.json();

    // Assert: 500 with a generic message, not the raw error
    expect(response.status).toBe(500);
    expect(data.error).not.toMatch(/sk-/);
    expect(data.error).not.toMatch(/invalid API key/);
  });
});
